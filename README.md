# CS340Repo
Git repository for CS-340
1. How do you write programs that are maintainable, readable, and adaptable? Especially consider your work on the CRUD Python module from Project One, which you used to connect the dashboard widgets to the database in Project Two. What were the advantages of working in this way? How else could you use this CRUD Python module in the future?

Writing maintainable, readable, and adaptable programs starts with clear separation of concerns, stable interfaces, and consistent conventions. In this course I applied those principles by encapsulating database access in a reusable CRUD Python module. By centralizing create, read, update, and delete operations in the AnimalShelter class, I isolated persistence logic from presentation concerns in the Dash dashboard. This reduced duplication, simplified testing, and made changes safer, for example, improving error handling or authentication in one place immediately benefited every widget that depended on the module. That approach also made the code more adaptable: the same module can support different dashboards, command-line utilities, or data pipelines with no changes to the UI. Looking forward, I could extend the module with pagination helpers, aggregation methods, and schema validation, or repoint it to a different collection or database while keeping the client code stable.

2. How do you approach a problem as a computer scientist? Consider how you approached the database or dashboard requirements that Grazioso Salvare requested. How did your approach to this project differ from previous assignments in other courses? What techniques or strategies would you use in the future to create databases to meet other client requests?

I approached the problem like a computer scientist by turning the client’s high-level requirements into testable specifications and then mapping those specifications to an architecture that respects the MVC pattern. For Grazioso Salvare, that meant translating “find dogs suited for water, wilderness, and disaster rescue” into precise database queries based on breed lists, sex, and age windows, and then building controller callbacks that propagate filter choices to the data table and charts. Compared with earlier coursework, this project demanded more end-to-end thinking: security with authenticated MongoDB access, performance through indexes and efficient projections, resilience with graceful handling of missing coordinates, and user experience via single-row selection defaults, pagination, and clear visuals. In future client projects, I would continue to start from a domain model and data contract, define indices up front for expected access patterns, validate inputs at the controller boundary, and drive UI behavior from a small set of well-specified state variables to keep complexity in check.

3. What do computer scientists do, and why does it matter? How would your work on this type of project help a company, like Grazioso Salvare, to do their work better?

Computer scientists design systems that transform ambiguous goals into reliable, scalable, and trustworthy software. That matters because organizations depend on timely, accurate information to make decisions, and the cost of poor data plumbing or fragile interfaces compounds quickly. On a project like this, my work helps a company such as Grazioso Salvare operate more effectively by turning raw shelter data into actionable insight: staff can apply domain filters that reflect real rescue criteria, instantly see candidates in a sortable table, verify details on a map, and share consistent results across the team. Beyond convenience, the design choices such as modular CRUD access, authenticated connections, and reproducible dashboards. Also, reduce onboarding time, lower maintenance risk, and make it easier to extend the system when the client’s needs evolve. In short, thoughtful engineering converts data into decisions, and that directly advances the mission of organizations like Grazioso Salvare.
